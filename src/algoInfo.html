<div data-type='encryption' id='IDEA'>
	<p>IDEA является блочным алгоритмом шифрования данных, запатентованным швейцарской фирмой Ascom. Фирма, правда, разрешила бесплатное некоммерческое использование своего алгоритма (применяется в общедоступном пакете конфиденциальной версии электронной почты PGP). Здесь в отличие от алгоритма DES не используются S-блоки или таблицы просмотра. В IDEA применяются 52 субключа, каждый длиной 16 бит. Исходный текст в IDEA делится на четыре группы по 16 бит. Для того чтобы комбинировать 16 битные коды, используется три операции: сложение, умножение и исключающее ИЛИ. Сложение представляет собой обычную операцию по модулю 65536 с переносом. При составлении таблицы умножения принимаются специальные меры для того, чтобы операция была обратимой. По этой причине вместо нуля используется код 65536. Рассмотрим алгоритм IDEA.</p>
	<p>Пусть четыре четверти исходного текста имеют имена A, B, C и D, а 52 субключа - К(1), К(2),…, К(52). Перед реализацией алгоритма выполняются операции:</p>
	<p><b>А = А*К(1); B = B + K(2); C = C + K(3); D = D * K(4);</b></p>
	<p>Первый цикл вычислений включает в себя:</p>
	<p>
		<b>E = A XOR C; F = B XOR D</b><br>
		<b>E = E * K(5)</b><br>
		<b>F = F + E</b><br>
		<b>F = F * K(6)</b><br>
		<b>E = E + F</b><br>
		<b>A = A XOR F</b><br>
		<b>C = C XOR F</b><br>
		<b>B = B XOR E</b><br>
		<b>D = D XOR E</b>
	</p>
	<p>Меняем местами В и С.</p>
	<p>Повторяем это всё 8 раз, используя К(7) - К(12) для второго раза и, соответственно, К(43) - К(48) - для восьмого. После восьмого раза В и С местами не меняются. Выполняем после этого операции:</p>
	<p>
		<b>A = A * K(49)</b><br>
		<b>B = B + K(50)</b><br>
		<b>C = C + K(51)</b><br>
		<b>D = D * K(52)</b>
	</p>
	<p>В результате закодированный текст имеет ту же длину, что и исходный. Схема этого весьма запутанного алгоритма может быть пояснена на рис. 1. По своему характеру алгоритм напоминает процедуры вычисления хэш-функции.</p>
	<p><center><img src="img/IDEA.png" /></center></p>
	<p><center>Рис. 1 - Схема реализации алгоритма шифрования IDEA</center></p>
	<p>При дешифровке используется тот факт, что A XOR B не изменяется, если C A и B будет произведена операция XOR C использованием любого числа. Это утверждение справедливо для любых значений А и В. Операции сложения (слагаемые заменяются их дополнением по модулю 2) и умножения (множители заменяются из обратными величинами по модулю 65537) также допускают инверсию. Первые четыре ключа дешифровки (KD) определяются несколько иначе, чем остальные.</p>
	<p>
		<b>KD(1) = 1/K(49)</b><br>
		<b>KD(2) = -K(50)</b><br>
		<b>KD(3) = -K(51)</b><br>
		<b>KD(4) = 1/K(52)</b>
	</p>
	<p>Последующие операции производятся восемь раз с добавлением 6 к индексу ключей дешифрования и вычитанием 6 из индекса ключей шифрования.</p>
	<p>
		<b>KD(5) = K(47)</b><br>
		<b>KD(6) = K(48)</b><br>
		<b>KD(7) = 1/K(43)</b><br>
		<b>KD(8) = -K(45)</b><br>
		<b>KD(9) = -K(44)</b><br>
		<b>KD(10) = 1/K(46)</b>
	</p>
	<p>Субключи IDEA генерируются следующим образом. 128-битовый ключ IDEA определяет первые восемь субключей (128=8*16). Последующие ключи (44) получаются путем последовательности циклических сдвигов влево этого кода на 25 двоичных разрядов.</p>
</div>

<div data-type='encryption' id='DES'>
<p>DES представляет собой блочный шифр, он шифрует данные 64-битовыми блоками. С одного конца алгоритма вводится 64-битовый блок открытого текста, а с другого конца выходит 64-битовый блок шифротекста. DES является симметричным алгоритмом: для шифрования и дешифрирования используются одинаковые алгоритм и ключ (за исключением небольших различий в использовании ключа).</p>
<p>Длина ключа равна 56 битам. (Ключ обычно представляется 64-битовым числом, но каждый восьмой бит используется для проверки четности и игнорируется. Биты четности являются наименьшими значащими битами байтов ключа.) Ключ, который может быть любым 56-битовым числом, можно изменить в любой момент времени. Ряд чисел считаются слабыми ключами, но их можно легко избежать. Безопасность полностью определяется ключом.</p>
<p>На простейшем уровне алгоритм не представляет ничего большего, чем комбинация двух основных методов шифрования: смещения и диффузии. Фундаментальным строительным блоком DES является применение к тексту единичной комбинации этих методов (подстановка, а за ней - перестановка), зависящей от ключа. Такой блок называется этапом. DES состоит из 16 этапов, одинаковая комбинация методов применяется к открытому тексту 16 раз, как показано на рисунке 1.</p>
<p>Алгоритм использует только стандартную арифметику 64-битовых чисел и логические операции, поэтому он легко реализовывался в аппаратуре второй половины 70-х. Изобилие повторений в алгоритме делает его идеальным для реализации в специализированной микросхеме.</p>

<p><center>
	<img src="img/DES.png" /><br>
	Рисунок 1 - DES
</center></p>

<p>DES работает с 64-битовым блоком открытого текста. После первоначальной перестановки блок разбивается на правую и левую половины длиной по 32 бита. Затем выполняется 16 этапов одинаковых действий, называемых функцией f, в которых данные объединяются с ключом. После шестнадцатого этапа правая и левая половины объединяются и алгоритм завершается заключительной перестановкой (обратной по отношению к первоначальной).</p>
<p>На каждом этапе (рисунок 2) биты ключа сдвигаются, и затем из 56 битов ключа выбираются 48 битов. Правая половина данных увеличивается до 48 битов с помощью перестановки с расширением, объединяется посредством XOR с 48 битами смещенного и переставленного ключа, проходит через 8 S-блоков, образуя 32 новых бита, и переставляется снова. Эти четыре операции и выполняются функцией f. Затем результат функции f объединяется с левой половиной с помощью другого XOR. В итоге этих действий появляется новая правая половина, а старая правая половина становится новой левой. Эти действия повторяются 16 раз, образуя 16 этапов DES.</p>
 
<p><center>
	<img src="img/DES_first.png" /><br>
	Рисунок 2 - Один этап DES
</center></p>

<p>Начальная перестановка выполняется еще до этапа 1, при этом входной блок переставляется. Например, начальная перестановка перемещает бит 58 в битовую позицию 1, бит 50 - в битовую позицию 2, бит 42 - в битовую позицию 3, и так далее.</p>

Таблица 1 - Начальная перестановка
<table>
	<tr>
		<td>58</td><td>50</td><td>42</td><td>34</td><td>26</td><td>18</td><td>10</td><td>2</td><td>60</td><td>52</td><td>44</td><td>36</td><td>28</td><td>20</td><td>12</td><td>4</td>
	</tr>
	<tr>
		<td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td><td>14</td><td>6</td><td>64</td><td>56</td><td>48</td><td>40</td><td>32</td><td>24</td><td>16</td><td>8</td>
	</tr>
	<tr>
		<td>57</td><td>49</td><td>51</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td>
	</tr>
	<tr>
		<td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td><td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td>
	</tr>
</table>

<p>Начальная перестановка и соответствующая заключительная перестановка не влияют на безопасность DES. Как можно легко заметить, эта перестановка в первую очередь служит для облегчения побайтной загрузки данных открытого текста и шифротекста в микросхему DES.</p>
Преобразования ключа
<p>Сначала 64-битовый ключ DES уменьшается до 56-битового ключа отбрасыванием каждого восьмого бита. Эти биты используются только для контроля четности, позволяя проверять правильность ключа. После извлечения 56-битового ключа для каждого из 16 этапов DES генерируется новый 48-битовый подключ. Эти подключи, К, определяются следующим образом.</p>

Таблица 2 - Перестановка ключа
<table>
	<tr>
		<td>57</td><td>49</td><td>41</td><td>33</td><td>25</td><td>17</td><td>9</td><td>1</td><td>58</td><td>50</td><td>42</td><td>34</td><td>26</td><td>18</td>
	</tr>
	<tr>
		<td>10</td><td>2</td><td>59</td><td>51</td><td>43</td><td>35</td><td>27</td><td>19</td><td>11</td><td>3</td><td>60</td><td>52</td><td>44</td><td>36</td>
	</tr>
	<tr>
		<td>63</td><td>55</td><td>47</td><td>39</td><td>31</td><td>23</td><td>15</td><td>7</td><td>62</td><td>54</td><td>46</td><td>38</td><td>30</td><td>22</td>
	</tr>
	<tr>
		<td>14</td><td>6</td><td>61</td><td>53</td><td>45</td><td>37</td><td>29</td><td>21</td><td>13</td><td>5</td><td>28</td><td>20</td><td>12</td><td>4</td>
	</tr>
</table>

<p>Сначала 56-битовый ключ делится на две 28-битовых половинки. Затем, половинки циклически сдвигаются налево на один или два бита в зависимости от этапа, в соответствии с данными таблицы 3.</p> 

Таблица 3 - Число битов сдвига ключа в зависимости от этапа
<table>
	<tr>
		<td>Этап</td>
		<td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td>
	</tr>
	<tr>
		<td>Число</td>
		<td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td>
	</tr>
</table>

<p>После сдвига выбирается 48 из 56 битов. Так как при этом не только выбирается подмножество битов, но и изменяется их порядок, эта операция называется перестановка со сжатием. Ее результатом является набор из 48 битов. Перестановка со сжатием (также называемая переставленным выбором) показана в таблице 4. Например, бит сдвинутого ключа в позиции 33 перемещается в позицию 35 результата, а 18-й бит сдвинутого ключа отбрасывается.</p>

Таблица 4 - Перестановка со сжатием
<table>
	<tr>
		<td>14</td><td>17</td><td>11</td><td>24</td><td>1</td><td>5</td><td>3</td><td>28</td><td>15</td><td>6</td><td>21</td><td>10</td>
	</tr>
	<tr>
		<td>23</td><td>19</td><td>11</td><td>4</td><td>26</td><td>8</td><td>16</td><td>7</td><td>27</td><td>20</td><td>13</td><td>2</td>
	</tr>
	<tr>
		<td>41</td><td>52</td><td>31</td><td>37</td><td>47</td><td>55</td><td>30</td><td>40</td><td>51</td><td>45</td><td>33</td><td>48</td>
	</tr>
	<tr>
		<td>44</td><td>49</td><td>39</td><td>56</td><td>34</td><td>53</td><td>46</td><td>42</td><td>50</td><td>36</td><td>29</td><td>32</td>
	</tr>
</table>

<p>Из-за сдвига для каждого подключа используется отличное подмножество битов ключа. Каждый бит используется приблизительно в 14 из 16 подключей, хотя не все биты используются в точности одинаковое число раз.</p>
<p>Перестановка с расширением расширяет правую половину данных, К, от 32 до 48 битов. Так как при этом не просто повторяются определенные биты, но и изменяется их порядок, эта операция называется перестановкой с расширением. У нее две задачи: привести размер правой половины в соответствие с ключом для операции XOR и получить более длинный результат, который можно будет сжать в ходе операции подстановки. Однако главный криптографический смысл совсем в другом. За счет влияния одного бита на две подстановки быстрее возрастает зависимость битов результата от битов исходных данных. Это называется лавинным эффектом. DES спроектирован так, чтобы как можно быстрее добиться зависимости каждого бита шифротекста от каждого бита открытого текста и каждого бита ключа.</p>
<p>Перестановка с расширением показана на рисунке 3. Иногда она называется E-блоком (от expansion). Для каждого 4-битового входного блока первый и четвертый бит представляют собой два бита выходного блока, а второй и третий биты - один бит выходного блока. В таблице 5 показано, какие позиции результата соответствуют каким позициям исходных данных. Например, бит входного блока в позиции 3 переместится в позицию 4 выходного блока, а бит входного блока в позиции 21 - в позиции 30 и 32 выходного блока.</p>
 
<p><center>
	<img src="img/DES_expansion.jpg" /><br>
	Рисунок 3 - Перестановка с расширением
</center></p>

<p>Хотя выходной блок больше входного, каждый входной блок генерирует уникальный выходной блок.</p>

Таблица 5 - Перестановка с расширением
<table>
	<tr>
		<td>32</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td>
	</tr>
	<tr>
		<td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>17</td>
	</tr>
	<tr>
		<td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>20</td><td>21</td><td>22</td><td>23</td><td>24</td><td>25</td>
	</tr>
	<tr>
		<td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>28</td><td>29</td><td>30</td><td>31</td><td>32</td><td>1</td>
	</tr>
</table>

<p>Подстановка с помощью S-блоков. После объединения сжатого блока с расширенным блоком с помощью XOR над 48-битовым результатом выполняется операция подстановки. Подстановки производятся в восьми  блоках подстановки, или S-блоках (от substitution). У каждого S-блока 6-битовый вход и 4-битовый выход, всего используется восемь различных S-блоков. (Для восьми S-блоков DES потребуется 256 байтов памяти.) 48 битов делятся на восемь 6-битовых подблока. Каждый отдельный подблок обрабатывается отдельным S-блоком: первый подблок - S-блоком 1, второй - S-блоком 2, и так далее. Принцип использования S-блоков показан на рисунке 4.</p>


<p><center>
	<img src="img/DES_sblock.jpg" /><br>
	Рисунок 4 - Подстановка - S-блоки
</center></p>

<p>Каждый S-блок представляет собой таблицу из 4 строк и 16 столбцов. Каждый элемент в блоке является 4-битовым числом. По 6 входным битам S-блока определяется, под какими номерами столбцов и строк следует искать выходное значение.</p>
<p>Конечно же, намного легче реализовать S-блоки программно в виде массивов с 64 элементами. Для этого потребуется переупорядочить элементы, что не является трудной задачей. (Изменить индексы, не изменяя порядок элементов, недостаточно. S-блоки спроектированы очень тщательно.) Однако такой способ описания S-блоков помогает понять, как они работают. Каждый S-блок можно рассматривать как функцию подстановки 4-битового элемента: биты c b2 по b5 служат входом, а некоторое 4-битовое число - результатом. Биты b1 и b6 определяются соседними блоками, они определяют одну из четырех функций подстановки, возможных в данном S-блоке.</p>
<p>Подстановка с помощью S-блоков является ключевым этапом DES. Другие действия алгоритма линейны и легко поддаются анализу. S-блоки нелинейны, и именно они в большей степени, чем все остальное, обеспечивают безопасность DES.</p>
<p>В результате этого этапа подстановки получаются восемь 4-битовых блоков, которые вновь объединяются в единый 32-битовый блок. Этот блок поступает на вход следующего этапа - перестановки с помощью P-блоков.</p>
<p>Перестановка с помощью Р-блоков. 32-битовый выход подстановки с помощью S-блоков, перетасовываются в соответствии с P-блоком. Эта перестановка перемещает каждый входной бит в другую позицию, ни один бит не используется дважды, и ни один бит не игнорируется. Этот процесс называется прямой перестановкой или просто перестановкой. Позиции, в которые перемещаются биты, показаны в таблице 6. Например, бит 21 перемещается в позицию 4, а бит 4 - в позицию 31.</p>

Таблица 6 - Перестановка с помощью P-блоков
<table>
	<tr>
		<td>16</td><td>7</td><td>20</td><td>21</td><td>29</td><td>12</td><td>28</td><td>17</td><td>1</td><td>15</td><td>23</td><td>26</td><td>5</td><td>18</td><td>31</td><td>10</td>
	</tr>
	<tr>
		<td>2</td><td>8</td><td>24</td><td>14</td><td>32</td><td>27</td><td>3</td><td>9</td><td>19</td><td>13</td><td>30</td><td>6</td><td>22</td><td>11</td><td>4</td><td>25</td>
	</tr>
</table>

<p>Наконец, результат перестановки с помощью P-блока объединяется посредством XOR с левой половиной первоначального 64-битового блока. Затем левая и правая половины меняются местами, и начинается следующий этап.</p>
<p>Заключительная перестановка является обратной по отношению к начальной перестановки и показана в таблице 7. Обратите внимание, что левая и правая половины не меняются местами после последнего этапа DES, вместо этого объединенный блок R16L16 используется как вход заключительной перестановки. В этом нет ничего особенного, перестановка половинок с последующим циклическим сдвигом привела бы к точно такому же результату. Это сделано для того, чтобы алгоритм можно было использовать как для шифрования, так и для дешифрования.</p>

Таблица 7 - Заключительная перестановка
<table>
	<tr>
		<td>40</td><td>8</td><td>48</td><td>16</td><td>56</td><td>24</td><td>64</td><td>32</td><td>39</td><td>7</td><td>47</td><td>15</td><td>55</td><td>23</td><td>63</td><td>31</td>
	</tr>
	<tr>
		<td>38</td><td>6</td><td>46</td><td>14</td><td>54</td><td>22</td><td>62</td><td>30</td><td>37</td><td>5</td><td>45</td><td>13</td><td>53</td><td>21</td><td>61</td><td>29</td>
	</tr>
	<tr>
		<td>36</td><td>4</td><td>44</td><td>12</td><td>52</td><td>20</td><td>60</td><td>28</td><td>35</td><td>3</td><td>43</td><td>11</td><td>51</td><td>19</td><td>59</td><td>27</td>
	</tr>
	<tr>
		<td>34</td><td>2</td><td>42</td><td>10</td><td>50</td><td>18</td><td>58</td><td>26</td><td>33</td><td>1</td><td>41</td><td>9</td><td>49</td><td>17</td><td>57</td><td>25</td>
	</tr>
</table>

<p>DES позволяет использовать для шифрования или дешифрирования блока одну и ту же функцию. Единственное отличие состоит в том, что ключи должны использоваться в обратном порядке. То есть, если на этапах шифрования использовались ключи К1, К2, К3, ..., К16, то ключами дешифрирования будут К16, К15, К14, ..., К1.</p>

</div>

<div data-type='encryption' id='GOST'>
	<p>Отечественный алгоритм шифрования ГОСТ 28147-89 шифрует данные 64-битными блоками с использованием 256-битного ключа шифрования. Выполняется 32 раунда преобразований, в каждом из которых предусмотрены следующие операции (см. рисунок 1):
	<ol>
		<li>Один из 32-битных субблоков данных складывается с 32-битным значением ключа раунда Ki по модулю 232.</li>
		<li>Результат предыдущей операции разбивается на 8 фрагментов по 4 бита, которые параллельно «прогоняются» через 8 таблиц замен S1…S8. Таблицы замен в стандарте не определены. </li>
		<li>4-битные фрагменты (после замен) объединяются обратно в 32-битный субблок, значение которого циклически сдвигается влево на 11 бит. </li>
		<li>Обработанный предыдущими операциями субблок накладывается на необработанный с помощью побитовой логической операции «исключающее или» (XOR). </li>
		<li>Субблоки меняются местами.</li>
	</ol>
	</p>

	<p><center>
		<img src="img/GOST_feistel.png" /><br>
		Рисунок 1 - Раунд алгоритма ГОСТ 28147-89
	</center></p>

	<p>Процедура расширения ключа в алгоритме ГОСТ 28147-89, фактически, отсутствует: в раундах шифрования последовательно используются 32-битные фрагменты K1…K8 исходного 256-битного ключа шифрования в следующем порядке: <br>
	<strong>K1, K2, K3, K4, K5, K6, K7, K8</strong><br>
	– за исключением последних 8 раундов – в раундах с 25-го по 31-й фрагменты используются в обратном порядке.</p>
	<p>Расшифрование полностью аналогично зашифрованию, но с другим порядком использования фрагментов ключа: 
	<ul>
		<li>в прямом порядке – в первых 8 раундах;</li> 
		<li>в остальных раундах – в обратном порядке.</li> 
	</ul>
	Стандарт также предусматривает и описывает различные режимы применения алгоритма:
	<ul>
		<li>описанный выше режим простой замены;</li> 
		<li>режимы гаммирования и гаммирования с обратной связью, предусматривающие вычисление с помощью описанных выше преобразований псевдослучайной последовательности – гаммы шифра – и ее наложение на шифруемый текст;</li>
		<li>режим вычисления имитовставки – криптографической контрольной суммы, используемой для подтверждения целостности данных; в данном режиме выполняется 16 раундов преобразований вместо 32-х.</li>
	</ul>
	</p>
	<p>Алгоритм ГОСТ 28147-89 можно использовать и в различных общеупотребительных режимах шифрования (предусмотренных стандартом). Кроме того, на основе данного алгоритма построен отечественный стандарт хэширования ГОСТ Р 34.11-94.
	</p>
	<p>
	Как видно из описания, алгоритм ГОСТ 28147-89 является весьма простым в реализации, что является его несомненным достоинством.
	</p>
	<p>
	Поскольку таблицы замен в стандарте не приведены, то существуют так  называемые «хорошие» и «плохие» таблицы замен. Поэтому криптостойкость алгоритма во многом зависит от свойств используемых таблиц замен, соответственно, существуют слабые таблицы замен, применение которых может упростить вскрытие алгоритма. Тем не менее, возможность использования различных таблиц замен кажется весьма достойной идеей.
	</p>
</div>


<div data-type='encryption' id='RSA'>
	<h3>Алгоритм создания открытого и секретного ключей</h3>

	RSA-ключи генерируются следующим образом:
	<ol>
	    <li>Выбираются два различных случайных простых числа <i>p</i> и <i>q</i> заданного размера (например, 1024 бита каждое).</li>
	    <li>Вычисляется их произведение <i>n = p * q</i>, которое называется модулем.</li>
	    <li>Вычисляется значение функции Эйлера от числа <i>n</i>:
			<br><i>&Phi;(n) = (p - 1)(q - 1)</i>.
		</li>
	    <li>Выбирается целое число <i>e(1 < e < &Phi;(n))</i>, взаимно простое со значением функции <i>&Phi;(n)</i>. Обычно в качестве e берут простые числа, содержащие небольшое количество единичных бит в двоичной записи, например, простые числа Ферма 17, 257 или 65537.
	        <ul><li>Число <i>e</i> называется открытой экспонентой</li>
	        <li>Время, необходимое для шифрования с использованием быстрого возведения в степень, пропорционально числу единичных бит в e.</li>
	        <li>Слишком малые значения <i>e</i>, например 3, потенциально могут ослабить безопасность схемы RSA.</li></ul>
	    </li>
	    <li>Вычисляется число <i>d</i>, мультипликативно обратное к числу e по модулю <i>&Phi;(n)</i>, то есть число, удовлетворяющее условию:
	        <br><i>d * e &equiv; 1 mod &Phi;(n)</i>.
	        <ul><li>Число <i>d</i> называется секретной экспонентой. Обычно, оно вычисляется при помощи расширенного алгоритма Евклида.</li></ul>
	    </li>
	    <li>Пара <i>{e, n}</i> публикуется в качестве открытого ключа RSA.</li>
	    Пара <i>{d, n}</i> играет роль закрытого ключа RSA и держится в секрете.
	</ol>

	<br><br>

	<h3>Шифрование и расшифрование</h3>
	<p>Предположим, Боб хочет послать Алисе сообщение <i>m</i>.</p>

	<p>Сообщениями являются целые числа в интервале от <i>0</i> до <i>n - 1</i>, т.е <i>m &isin; Z<sub>n</sub></i>.</p>
	<center><img src="img/RSA.png" /></center>
	<p>Алгоритм:
	<ul>
	    <li>Боб берет открытый ключ <i>{e, n}</i> Алисы</li>
	    <li>Берет открытый текст <i>m</i></li>
	    <li>Зашифровывает сообщение с использованием открытого ключа Алисы:
			<br><i>c = E(m) = m<sup>e</sup> mod n</i>
		</li>
	    <li>Отправляет зашифрованное сообщение <i>c</i> Алисе</li>
	    <li>Алиса берет свой закрытый ключ <i>{d, n}</i></li>
	    <li>Применяет закрытый ключ для расшифрования сообщения:
	        <br><i>m = D(c) = c<sup>d</sup> mod n</i>
	    </li>
	</ul>
	</p>
</div>



<div data-type='eds' id='RSA'>
	<h3>Алгоритм создания открытого и секретного ключей</h3>

	RSA-ключи генерируются следующим образом:
	<ol>
	    <li>Выбираются два различных случайных простых числа <i>p</i> и <i>q</i> заданного размера (например, 1024 бита каждое).</li>
	    <li>Вычисляется их произведение <i>n = p * q</i>, которое называется модулем.</li>
	    <li>Вычисляется значение функции Эйлера от числа <i>n</i>:
			<br><i>&Phi;(n) = (p - 1)(q - 1)</i>.
		</li>
	    <li>Выбирается целое число <i>e(1 < e < &Phi;(n))</i>, взаимно простое со значением функции <i>&Phi;(n)</i>. Обычно в качестве e берут простые числа, содержащие небольшое количество единичных бит в двоичной записи, например, простые числа Ферма 17, 257 или 65537.
	        <ul><li>Число <i>e</i> называется открытой экспонентой</li>
	        <li>Время, необходимое для шифрования с использованием быстрого возведения в степень, пропорционально числу единичных бит в e.</li>
	        <li>Слишком малые значения <i>e</i>, например 3, потенциально могут ослабить безопасность схемы RSA.</li></ul>
	    </li>
	    <li>Вычисляется число <i>d</i>, мультипликативно обратное к числу e по модулю <i>&Phi;(n)</i>, то есть число, удовлетворяющее условию:
	        <br><i>d * e &equiv; 1 mod &Phi;(n)</i>.
	        <ul><li>Число <i>d</i> называется секретной экспонентой. Обычно, оно вычисляется при помощи расширенного алгоритма Евклида.</li></ul>
	    </li>
	    <li>Пара <i>{e, n}</i> публикуется в качестве открытого ключа RSA.</li>
	    Пара <i>{d, n}</i> играет роль закрытого ключа RSA и держится в секрете.
	</ol>

	<br><br>

	<h3>Цифровая подпись</h3>
	<p>Предположим, что Алисе (стороне A) нужно отправить Бобу (стороне B) сообщение m, подтверждённое электронной цифровой подписью.</p>

	<center><img src="img/RSA_ecp.png" /></center>
	<p>Алгоритм:
	<ul>
	    <li>Алиса берет открытый текст <i>m</i></li>
	    <li>Создает цифровую подпись <i>s</i> с помощью своего секретного ключа <i>{d, n}</i><br>
	    	<i>s = S<sub>A</sub>(m) = m<sup>d</sup> mod n</i>
	    </li>
	    <li>Передает Бобу пару <i>{m, s}</i>, состоящую из сообщения и подписи</i>
		</li>
	    <li>Боб берет открытый ключ <i>{e, n}</i> Алисы</li>
	    <li>Вычисляет прообраз сообщения из подписи<br>
	    	<i>m' = P<sub>A</sub>(s) = s<sup>e</sup> mod n</i>
	    </li>
	    <li>Проверяет подлинность подписи (и неизменность сообщения), сравнив <i>m</i> и <i>m'</i>
	    </li>
	</ul>
	</p>
	<p>
		Поскольку цифровая подпись обеспечивает как аутентификацию автора сообщения, так и подтверждение целостности содержимого подписанного сообщения, она служит аналогом подписи, сделанной от руки в конце рукописного документа.
	</p>
	<p>
		Важное свойство цифровой подписи заключается в том, что её может проверить каждый, кто имеет доступ к открытому ключу её автора. Один из участников обмена сообщениями после проверки подлинности цифровой подписи может передать подписанное сообщение ещё кому-то, кто тоже в состоянии проверить эту подпись. Например, сторона <i>A</i>, может переслать стороне <i>B</i>, электронный чек. После того как сторона <i>B</i>, проверит подпись стороны <i>A</i>, на чеке, она может передать его в свой банк, служащие которого также имеют возможность проверить подпись и осуществить соответствующую денежную операцию.
	</p>
	<p>
		Заметим, что подписанное сообщение <i>m</i> не зашифровано. Оно пересылается в исходном виде и его содержимое не защищено от нарушения конфиденциальности. Путём совместного применения представленных выше схем шифрования и цифровой подписи в системе RSA можно создавать сообщения, которые будут и зашифрованы, и содержать цифровую подпись. Для этого автор сначала должен добавить к сообщению свою цифровую подпись, а затем — зашифровать получившуюся в результате пару (состоящую из самого сообщения и подписи к нему) с помощью открытого ключа принадлежащего получателю. Получатель расшифровывает полученное сообщение с помощью своего секретного ключа. Если проводить аналогию с пересылкой обычных бумажных документов, то этот процесс похож на то, как если бы автор документа поставил под ним свою печать, а затем положил его в бумажный конверт и запечатал, с тем чтобы конверт был распечатан только тем человеком, кому адресовано сообщение.
	</p>
</div>